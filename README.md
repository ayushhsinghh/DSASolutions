# DSA Solution : C++

## Recursion

* [Nth_fabonnaci](Recursion/Nth_Fabonnaci.cpp)
* [Product_Sum](Recursion/Product_Sum.py)
* [Tower of Hanoi](Recursion/TowerOfHanoi.cpp)

## Sorting

* [Bubble Sort](sorting/bubbleSort.cpp)
* [Insetion Sort](sorting/InsertionSort.cpp)
* [Merge Sort](sorting/mergeSort.cpp)
* [Quick Sort](sorting/quickSort.cpp)
* [Heap Sort](sorting/HeapSort.cpp)


## Linked List
* [Create LinkedList (Input and Print)](LinkedList/Create_LL.cpp)
* [Delete element from LinkedList](LinkedList/Deletation_LL.cpp)
* [Insert element to LinkedList](LinkedList/Insertion_LL.cpp)
* [Traverse LinkedList](LinkedList/Traversal_LL.cpp)
* [Reverse a LinkedList](LinkedList/reverse_LL.cpp)
* [MergeSort on LinkedList](LinkedList/mergeSort_LinkedList.cpp)


## Generic Tree
* [Generic Tree Basics(Input , Traversal)](GenericTree/GenericTrees_Basics.cpp)

## BinaryTree

* [Binary Tree Traversal(Pre , Post , In , Level)](BinaryTree/BinaryTree_Traversal.cpp)
* [Height Of Binary Tree](BinaryTree/Height_BinaryTree.cpp)
* [Diameter of Binary Tree](BinaryTree/Diameter_BinaryTree.cpp)
* [Mirror Image of BinaryTree](BinaryTree/Mirror_of_BinaryTree.cpp)
* [Left View Binary Tree](BinaryTree/leftViewBinaryTree.cpp)
* [Right View Binary Tree](BinaryTree/rightViewBinaryTree.cpp)
* [Min. and Max. of BinaryTree](BinaryTree/Max_Min_BinaryTree.cpp)
* [Path from Root to Node](BinaryTree/Path_From_Root_to_Node.cpp)


## Binary Search Tree

* [Search In Binary Search Tree](BinarySearchTree/SearchInBST.cpp)
* [Print Range In Binary Search Tree](BinarySearchTree/printRangeInBST.cpp)
* [Check BST (Triplet class)](BinarySearchTree/check_BST.cpp)
* [Check BST (Range Comparison)](BinarySearchTree/check_BST_BetterWay.cpp)
* [Binary Search Tree From Sorted Array](BinarySearchTree/BST_From_Sorted_Array.cpp)
* [Binary Search Tree To Sorted Linked List](BinarySearchTree/BST_To_Sorted_LInkedList.cpp)
* [BinarySearchTree Class (Insert , Delete , Traverse , Search)](BinarySearchTree/BST_Class_Insert_Delete_print_search.cpp)
* [AVL Tree Class (Insert , Delete , Traverse)](BinarySearchTree/AVL_Tree_Class.cpp)

## Priority Queue & Heap

* [Min Heap Class (Insert , Remove , GetMin)](PriorityQuery_Heap/Min_Heap_Class.cpp)
* [Max Heap Class (Insert , Remove , GetMax)](PriorityQuery_Heap/Max_Heap_class.cpp)
* [Heap Sort - InPlace](PriorityQuery_Heap/HeapSort_Inplace.cpp)
* [K Sorted Array - InPlace](PriorityQuery_Heap/K_Sorted_Array.cpp)
* [K Smallest Element - Priority Queue](PriorityQuery_Heap/K_Smallest_element.cpp)


## Trie & Huffman
* [Trie Class - Insert , Search , Remove](TrieAndHuffman/Trie_Class(Insert,Remove,Search).cpp)


## Dynamic Programming & Memoization

* [0-1 Knapsack - DP , Memoization , Recursion](DynamicProgramming/0-1_Knapsack.cpp)

<details>
  <summary> Subset Sum Problem - DP </summary>


```
Given a set of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.
Example:

Input:  set[] = {3, 34, 4, 12, 5, 2}, sum = 9
Output:  True  
Why? There is a subset (4, 5) with sum 9.
```

* [Subset Sum Problem - DP](DynamicProgramming/Subset_Sum.cpp)


</details>

<details>
  <summary> Equal Sum Partition Problem - DP </summary>


```
Question : Partition problem is to determine whether a given set can be partitioned into two subsets such 
that the sum of elements in both subsets is same.
Examples:

arr[] = {1, 5, 11, 5}
Output: true 
The array can be partitioned as {1, 5, 5} and {11}
```

* [Equal Sum Partition Problem - DP](DynamicProgramming/Equal_Sum_Partition.cpp)


</details>

<hr>

##### Language C++